<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | 黑夜键盘手的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/Book/avatar.png">
    <link rel="manifest" href="/Book/avatar.png">
    <link rel="apple-touch-icon" href="/Book/avatar.png">
    <meta name="description" content="黑夜键盘手的博客">
    <link rel="preload" href="/Book/assets/css/0.styles.1ab913a7.css" as="style"><link rel="preload" href="/Book/assets/js/app.e93a8c16.js" as="script"><link rel="preload" href="/Book/assets/js/2.ae30280c.js" as="script"><link rel="preload" href="/Book/assets/js/15.e7acb49b.js" as="script"><link rel="prefetch" href="/Book/assets/js/10.1c79b0fd.js"><link rel="prefetch" href="/Book/assets/js/11.42bc8cb7.js"><link rel="prefetch" href="/Book/assets/js/12.1d6a8d24.js"><link rel="prefetch" href="/Book/assets/js/13.89de5630.js"><link rel="prefetch" href="/Book/assets/js/14.ccab402b.js"><link rel="prefetch" href="/Book/assets/js/16.bbdfe50c.js"><link rel="prefetch" href="/Book/assets/js/3.8099ba9f.js"><link rel="prefetch" href="/Book/assets/js/4.c5015065.js"><link rel="prefetch" href="/Book/assets/js/5.127bcce8.js"><link rel="prefetch" href="/Book/assets/js/6.1db77680.js"><link rel="prefetch" href="/Book/assets/js/7.3dd4a00f.js"><link rel="prefetch" href="/Book/assets/js/8.889330e5.js"><link rel="prefetch" href="/Book/assets/js/9.05501753.js">
    <link rel="stylesheet" href="/Book/assets/css/0.styles.1ab913a7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Book/" class="home-link router-link-active"><img src="/Book/avatar.png" alt="黑夜键盘手的博客" class="logo"> <span class="site-name can-hide">黑夜键盘手的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Book/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Book/html/" class="nav-link">
  html
</a></div><div class="nav-item"><a href="/Book/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/Book/javascript/" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/Book/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue
</a></div><div class="nav-item"><a href="/Book/wechat/" class="nav-link">
  小程序
</a></div><div class="nav-item"><a href="/Book/tools/" class="nav-link">
  工具/插件
</a></div><div class="nav-item"><a href="/Book/interview/" class="nav-link">
  前端面试专题
</a></div><div class="nav-item"><a href="/Book/company/" class="nav-link">
  公司相关
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Book/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Book/html/" class="nav-link">
  html
</a></div><div class="nav-item"><a href="/Book/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/Book/javascript/" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/Book/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue
</a></div><div class="nav-item"><a href="/Book/wechat/" class="nav-link">
  小程序
</a></div><div class="nav-item"><a href="/Book/tools/" class="nav-link">
  工具/插件
</a></div><div class="nav-item"><a href="/Book/interview/" class="nav-link">
  前端面试专题
</a></div><div class="nav-item"><a href="/Book/company/" class="nav-link">
  公司相关
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Book/vue/#前言" class="sidebar-link">前言</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#安装vantui" class="sidebar-link">安装vantui</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#按需引入" class="sidebar-link">按需引入</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#适配rem" class="sidebar-link">适配Rem</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#分别安装" class="sidebar-link">分别安装</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#自定义主题" class="sidebar-link">自定义主题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#按需引入时，自定义主题" class="sidebar-link">按需引入时，自定义主题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vant-ui-自带的文本样式溢出" class="sidebar-link">vant ui 自带的文本样式溢出</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue父子组件传递参数" class="sidebar-link">vue父子组件传递参数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#v-for-key值" class="sidebar-link">v-for key值</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue解除双向绑定" class="sidebar-link">vue解除双向绑定</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#mvc与-mvvm的区别" class="sidebar-link">MVC与 MVVM的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue的seo问题" class="sidebar-link">vue的seo问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#生命周期内create和mounted的区别" class="sidebar-link">生命周期内create和mounted的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue传递参数方法" class="sidebar-link">vue传递参数方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vuex组成和原理" class="sidebar-link">vuex组成和原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue-router的原理" class="sidebar-link">vue-router的原理?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#登录验证拦截-通过router" class="sidebar-link">登录验证拦截(通过router)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue-config-js的基础配置" class="sidebar-link">vue.config.js的基础配置</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue项目分环境打包配置" class="sidebar-link">vue项目分环境打包配置</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue中如何使用mock-js" class="sidebar-link">vue中如何使用mock.js</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#解决el-upload第二次或者第n次无法触发选择图片问题" class="sidebar-link">解决el-upload第二次或者第n次无法触发选择图片问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vue封装一个全局loading组件" class="sidebar-link">vue封装一个全局loading组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Book/vue/#vuex模块化及数据的获取详细步骤" class="sidebar-link">vuex模块化及数据的获取详细步骤</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>vue手册致力于提取组件的封装、事件方法的抽取等。</p> <h2 id="安装vantui"><a href="#安装vantui" class="header-anchor">#</a> 安装vantui</h2> <div class="language- extra-class"><pre class="language-text"><code>  npm i vant -S
</code></pre></div><h2 id="按需引入"><a href="#按需引入" class="header-anchor">#</a> 按需引入</h2> <p>安装babel-plugin-import</p> <div class="language- extra-class"><pre class="language-text"><code>  npm i babel-plugin-import -D
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//babel-config.js
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ],
  plugins: [
    [
      'import',
      {
        libraryName: 'vant',
        libraryDirectory: 'es',
        style: true
      },
      'vant'
    ]
  ]
}
</code></pre></div><p>在src下创建plugins文件夹，在该目录下创建index.js</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue'

&lt;!-- 导入组件 --&gt;
import {
    Button,
} from 'vant'

&lt;!-- 注册组件 --&gt;
Vue.use(Button)
</code></pre></div><p>然后在main.js中引入</p> <div class="language- extra-class"><pre class="language-text"><code>import '@/plugins'
</code></pre></div><p>随即可以在.vue文件中使用注册过的组件</p> <h2 id="适配rem"><a href="#适配rem" class="header-anchor">#</a> 适配Rem</h2> <p>Vant 中的样式默认使用px作为单位，移动端使用Rem会更好，官方文档推荐使用一下两个工具：</p> <ul><li>postcss-pxtorem是一款 postcss 插件，用于将单位转化为 rem</li> <li>lib-flexible用于设置 rem 基准值</li></ul> <h2 id="分别安装"><a href="#分别安装" class="header-anchor">#</a> 分别安装</h2> <div class="language- extra-class"><pre class="language-text"><code>npm install postcss-pxtorem -D
&amp;&amp;
npm i amfe-flexible
</code></pre></div><p>安装好后，在main.js引入amfe-flexible</p> <div class="language- extra-class"><pre class="language-text"><code>import 'amfe-flexible/index.js'
</code></pre></div><p>如果项目根目录有postcss.config.js文件直接打开，没有就直接创建一个，在根目录啊，别跑偏了（哈哈）！</p> <div class="language- extra-class"><pre class="language-text"><code>//postcss.config.js
module.exports = {
    plugins: {
      'autoprefixer': {
        overrideBrowserslist: [
          'Android 4.1',
          'iOS 7.1',
          'Chrome &gt; 31',
          'ff &gt; 31',
          'ie &gt;= 8'
        ]
      },
      'postcss-pxtorem': {
        rootValue: 37.5,
        propList: ['*']
      }
    }
}
</code></pre></div><p>PS：375px 即100%宽度，写px会自动rem处理，如果不想被rem处理，可以使用PX来写。</p> <h2 id="自定义主题"><a href="#自定义主题" class="header-anchor">#</a> 自定义主题</h2> <p>Vant 使用了Less对样式进行预处理，并内置了一些样式变量，通过替换样式变量即可定制你自己需要的主题。
下面是一些基本的样式变量，所有可用的颜色变量请参考官网配置文件。这里我直接采取的是自建less文件进行变量覆盖</p> <div class="language- extra-class"><pre class="language-text"><code>//src/assets/vant/vant-theme.les
@green: green;
@blue: darkblue
@red: pink;
</code></pre></div><h2 id="按需引入时，自定义主题"><a href="#按需引入时，自定义主题" class="header-anchor">#</a> 按需引入时，自定义主题</h2> <p>更改babel.config.js文件，由于上面步骤引入了，这里稍微更改点就行</p> <div class="language- extra-class"><pre class="language-text"><code>// babel-config.js
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ],
  plugins: [
    ['import', {
      libraryName: 'vant',
      libraryDirectory: 'es',
      // style: true
      style: name =&gt; `${name}/style/less`
    }, 'vant']
  ]
}

</code></pre></div><p>根目录创建vue.config.js文件，内容如下：</p> <div class="language- extra-class"><pre class="language-text"><code>//vue.config.js
const path = require('path')
module.exports = {
    css: {
        loaderOptions: {
            less: {
                modifyVars: {
                    // green: '#888',
                    hack: `true; @import &quot;${path.join(__dirname,'./src/assets/van-theme.less')}&quot;`
                }
            }
        }
    }
};
</code></pre></div><p>原文链接: https://segmentfault.com/a/1190000022043508</p> <h2 id="vant-ui-自带的文本样式溢出"><a href="#vant-ui-自带的文本样式溢出" class="header-anchor">#</a> vant ui 自带的文本样式溢出</h2> <div class="language- extra-class"><pre class="language-text"><code>单行 van-ellipsis
多行 vant-multi-ellipsis

</code></pre></div><h1 id="vue篇"><a href="#vue篇" class="header-anchor">#</a> Vue篇</h1> <h2 id="vue父子组件传递参数"><a href="#vue父子组件传递参数" class="header-anchor">#</a> vue父子组件传递参数</h2> <ul><li>父 --&gt;子: 通过props</li> <li>子 --&gt;父: 通过 $refs 或 $emit</li></ul> <h2 id="v-for-key值"><a href="#v-for-key值" class="header-anchor">#</a> v-for key值</h2> <p>不写key值会报warning, 和react的array渲染类似. 根据diff算法, 修改数组后, 写key值会复用, 不写会重新生成, 造成性能浪费或某些不必要的错误</p> <h2 id="vue解除双向绑定"><a href="#vue解除双向绑定" class="header-anchor">#</a> vue解除双向绑定</h2> <p><code>let obj = JSON.parse(JSON.stringify(this.temp1));</code></p> <h2 id="mvc与-mvvm的区别"><a href="#mvc与-mvvm的区别" class="header-anchor">#</a> MVC与 MVVM的区别</h2> <ul><li>model-数据层 view-视图层 controller-控制层</li> <li>MVC的目的是实现M和V的分离，单向通信，必须通过C来承上启下</li> <li>MVVM中通过VM（vue中的实例化对象）的发布者-订阅者模式实现双向绑定，数据绑定，dom事件监听</li> <li>区别：MVC和MVVM的区别并不是VM完全取代了C，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的重用</li></ul> <h2 id="vue的seo问题"><a href="#vue的seo问题" class="header-anchor">#</a> vue的seo问题</h2> <p>seo关系到网站排名, vue搭建spa做前后端分离不好做seo, 可通过其他方法解决:</p> <ul><li>SSR服务端渲染: 将同一个组件渲染为服务器端的 HTML 字符串.利于seo且更快.</li> <li>vue-meta-info, nuxt, prerender-spa-plugin页面预渲染等</li></ul> <h2 id="生命周期内create和mounted的区别"><a href="#生命周期内create和mounted的区别" class="header-anchor">#</a> 生命周期内create和mounted的区别</h2> <ul><li><strong>created</strong>: 在模板渲染成html前调用，即通常初始化某些数据，然后再渲染成视图。</li> <li><strong>mounted</strong>: 在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作和方法。</li></ul> <h2 id="vue传递参数方法"><a href="#vue传递参数方法" class="header-anchor">#</a> vue传递参数方法</h2> <ul><li>父子组件传参如上, v-bind :    v-on @</li> <li>兄弟组件传参:(通过EventBus事件总线实现)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 1. 新建eventBus.js
import Vue from 'vue'
export default new Vue
// 或直接在main.js中初始化EventBus(全局)
Vue.prototype.$EventBus = new Vue()

// 2. 发射与接收
// 如果是定义在eventBus.js中
import eventBus from 'eventBus.js'
eventBus.$emit()
eventBus.$on()

// 如果是定义在main.js中
this.bus.$emit()
this.bus.$on()

// 3. 移除监听
eventBus.$off()
</code></pre></div><h2 id="vuex组成和原理"><a href="#vuex组成和原理" class="header-anchor">#</a> vuex组成和原理</h2> <ul><li>组成: 组件间通信, 通过store实现全局存取</li> <li>修改: 唯一途径, 通过commit一个mutations(同步)或dispatch一个actions(异步)</li> <li>简写: 引入mapState、mapGetters、mapActions</li></ul> <h2 id="vue-router的原理"><a href="#vue-router的原理" class="header-anchor">#</a> vue-router的原理?</h2> <ul><li>vue-router用法
在router.js或者某一个路由分发页面配置path, name, component对应关系
<ul><li>每个按钮一个value, 在watch功能中使用this.$router.push实现对应跳转, 类似react的this.history.push</li> <li>或直接用router-link to去跳转, 类似react的link to</li></ul></li> <li>vue-router原理: 通过hash和History interface两种方式实现前端路由
<ul><li>HashHistory: 利用URL中的hash（“#”）;replace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由</li> <li>History interface: 是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作. pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改</li></ul></li></ul> <h2 id="登录验证拦截-通过router"><a href="#登录验证拦截-通过router" class="header-anchor">#</a> 登录验证拦截(通过router)</h2> <ul><li>先设置requireAuth:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>routes = [
    {
        name: 'detail',
        path: '/detail',
        meta: {
            requireAuth: true
        }
    },
    {
        name: 'login',
        path: '/login'
    }
]
</code></pre></div><ul><li>再配置router.beforeEach:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>router.beforeEach((from, to, next) =&gt; {
    if (to.meta.requireAuth) { // 判断跳转的路由是否需要登录
        if (store.state.token) { // vuex.state判断token是否存在
            next() // 已登录
        } else {
            next({
                path: '/login',
                query: {redirect: to.fullPath} // 将跳转的路由path作为参数，登录成功后跳转到该路由
            })
        }
    } else {
       next()
    }
})
</code></pre></div><h2 id="vue-config-js的基础配置"><a href="#vue-config-js的基础配置" class="header-anchor">#</a> vue.config.js的基础配置</h2> <div class="language- extra-class"><pre class="language-text"><code>    module.exports = {
        // 部署生产环境和开发环境下的URL。
        // 默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上
        // 例如 https://www.ruoyi.vip/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.ruoyi.vip/admin/，则设置 baseUrl 为 /admin/。
        publicPath: process.env.NODE_ENV === &quot;production&quot; ? &quot;/&quot; : &quot;/&quot;,
        // 在npm run build 或 yarn build 时 ，生成文件的目录名称（要和baseUrl的生产环境路径一致）（默认dist）
        outputDir: 'dist',
        // 用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下）
        assetsDir: 'static',
        // 是否开启eslint保存检测，有效值：ture | false | 'error'
        lintOnSave: process.env.NODE_ENV === 'development',
        // 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。
        productionSourceMap: false,
        devServer: {
            host: '0.0.0.0',
            // 是否自动浏览器
            open: true,
            //默认启动端口
            port: 8888,
            // 代理
            // proxy: {
            //     // detail: https://cli.vuejs.org/config/#devserver-proxy
            //     [process.env.VUE_APP_BASE_API]: {
            //         target: `http://localhost:8080`,
            //         changeOrigin: true,
            //         pathRewrite: {
            //             ['^' + process.env.VUE_APP_BASE_API]: ''
            //         }
            //     }
            // },
        disableHostCheck: true
    }
</code></pre></div><h2 id="vue项目分环境打包配置"><a href="#vue项目分环境打包配置" class="header-anchor">#</a> vue项目分环境打包配置</h2> <p>1.在package.json文件中配置对应打包命令</p> <div class="language- extra-class"><pre class="language-text"><code>package.json
    {
        &quot;scripts&quot;: {
            &quot;dev&quot;: &quot;vue-cli-service serve --open&quot;,
            &quot;build:test&quot;: &quot;vue-cli-service build --mode test&quot;,
            &quot;build:prod&quot;: &quot;vue-cli-service build:prod&quot;
        },
    }
</code></pre></div><p>2.创建并配置对应的文件,一个文件对应一个打包命令(文件以.env.开头)</p> <div class="language- extra-class"><pre class="language-text"><code>.env.development
    # 开发环境配置
    ENV = 'development

    # 开发环境请求地址
    VUE_APP_BASE_API = 'http://localhost:808'0

    # 路由懒加载
    VUE_CLI_BABEL_TRANSPILE_MODULES = true
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>.env.production
    # 正式环境配置
    ENV = 'production'

    # 正式环境请求地址
    VUE_APP_BASE_API = 'http://www.baidu.com'

    # 路由懒加载
    VUE_CLI_BABEL_TRANSPILE_MODULES = true
</code></pre></div><p>3.执行对应打包命令</p> <div class="language- extra-class"><pre class="language-text"><code>    //测试
    npm run build:test

    or

    //正式
    npm run build:prod
</code></pre></div><p>如此我们打包出来的请求接口前缀会根据打包文件中配置的VUE_APP_BASE_API地址而生成对应的地址，不用每次发布都更改请求地址。</p> <h2 id="vue中如何使用mock-js"><a href="#vue中如何使用mock-js" class="header-anchor">#</a> vue中如何使用mock.js</h2> <p>步骤一 安装mockjs</p> <div class="language- extra-class"><pre class="language-text"><code>    npm i mockjs -S
</code></pre></div><p>步骤二 在src下创建一个文件夹来存放mock数据，例如: /src/mock/goods.js</p> <p>步骤三 实例化Mock 构建模拟数据，也可copy以下代码</p> <div class="language-goods.js extra-class"><pre class="language-text"><code>
const Mock = require(&quot;mockjs&quot;);
let data = Mock.mock({
    &quot;data|100&quot;: [ //生成100条数据 数组
        {
            &quot;shopId|+1&quot;: 1,//生成商品id，自增1
            &quot;shopMsg&quot;: &quot;@ctitle(10)&quot;, //生成商品信息，长度为10个汉字
            &quot;shopName&quot;: &quot;@cname&quot;,//生成商品名 ， 都是中国人的名字
            &quot;shopTel&quot;: /^1(5|3|7|8)[0-9]{9}$/,//生成随机电话号
            &quot;shopAddress&quot;: &quot;@county(true)&quot;, //随机生成地址
            &quot;shopStar|1-5&quot;: &quot;&quot;, //随机生成1-5个星星
            &quot;salesVolume|30-1000&quot;: 30, //随机生成商品价格 在30-1000之间
            &quot;shopLogo&quot;: &quot;@Image(‘100x40‘,‘#c33‘, ‘#ffffff‘,‘小北鼻‘)&quot;, //生成随机图片，大小/背景色/字体颜色/文字信息
            &quot;food|7&quot;: [ //每个商品中再随机生成七个food
                {
                    &quot;foodName&quot;: &quot;@cname&quot;, //food的名字
                    &quot;foodPic&quot;: &quot;@Image(‘100x40‘,‘#c33‘, ‘#ffffff‘,‘小可爱‘)&quot;,//生成随机图片，大小/背景色/字体颜色/文字信息
                    &quot;foodPrice|1-100&quot;: 20,//生成1-100的随机数
                    &quot;aname|14&quot;: [
                        { 
                            &quot;aname&quot;: &quot;@cname&quot;, 
                            &quot;aprice|30-60&quot;: 20 
                        }
                    ]
                }
            ]
        }
    ]
})
//三个参数。第一个路径，第二个请求方式post/get，第三个回调，返回值
Mock.mock(/goods\/goodAll/, 'get', () =&gt; {
    return data
})
</code></pre></div><p>步骤四 在main.js中引入</p> <div class="language-main.js extra-class"><pre class="language-text"><code>    import '../src/mock/goods.js'
</code></pre></div><p>步骤五 在需要的页面中使用获取数据，axios会自动拦截goods.js中定义的接口</p> <div class="language-Home.vue extra-class"><pre class="language-text"><code>    import axios from 'axios

    mounted () {
        this.initData()
    },
    methods: {
        initData () {
            axios.get('/goods/goodsAll').then((data) =&gt; {
                console.log(data)
            })
        }
    }

</code></pre></div><h2 id="解决el-upload第二次或者第n次无法触发选择图片问题"><a href="#解决el-upload第二次或者第n次无法触发选择图片问题" class="header-anchor">#</a> 解决el-upload第二次或者第n次无法触发选择图片问题</h2> <p>给el-upload设置ref,在on-success || on-Error回调之后加入以下代码重置</p> <div class="language- extra-class"><pre class="language-text"><code>    this.$refs.refName.clearFiles()
</code></pre></div><h2 id="vue封装一个全局loading组件"><a href="#vue封装一个全局loading组件" class="header-anchor">#</a> vue封装一个全局loading组件</h2> <p>在src下创建base文件夹容纳基础的组件</p> <div class="language-Loading.vue extra-class"><pre class="language-text"><code>    &lt;template&gt;
  &lt;div v-if=&quot;show&quot; class=&quot;loading-container&quot;&gt;
    &lt;img src=&quot;../../assets/img/loading.gif&quot; alt=&quot;&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'Loading',
  props: {
    show: Boolean
  },
  data() {
    return {
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.loading-container {
  position: fixed;
  top:0;
  left:0;
  width:100%;
  height:100%;
  /* background-color: green; */
}
.loading-container img {
  width: 90px;
  height: 90px;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%,-50%);


}
&lt;/style&gt;
</code></pre></div><p>在util文件夹下创建loading.js</p> <div class="language-loading.js extra-class"><pre class="language-text"><code>import Vue from 'vue'
import loadingComponent from '@/base/Loading.vue'

const LoadingConstructor = Vue.extend(loadingComponent)

const instance = new LoadingConstructor({
  el: document.createElement('div')
})

instance.show = false // 默认隐藏
const loading = {
  show() { // 显示方法
    instance.show = true
    document.body.appendChild(instance.$el)
  },
  hide() { // 隐藏方法
    instance.show = false
  }
}

export default {
  install() {
    if (!Vue.$loading) {
      Vue.$loading = loading
    }
    Vue.mixin({
      created() {
        this.$loading = Vue.$loading
      }
    })
  }
}

</code></pre></div><p>在main.js中注册</p> <div class="language- extra-class"><pre class="language-text"><code>import loading from '@/util/loading.js'
Vue.use(loading)
</code></pre></div><p>在组建中使用</p> <div class="language- extra-class"><pre class="language-text"><code>//显示方法
this.$loading.show()
//隐藏方法
this.$loading.hide()
</code></pre></div><h1 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h1> <h2 id="vuex模块化及数据的获取详细步骤"><a href="#vuex模块化及数据的获取详细步骤" class="header-anchor">#</a> vuex模块化及数据的获取详细步骤</h2> <p>我在项目中创建了两个页面 home和me，home的作用适用于提交数据然后跳转到me页面，me页面获取vuex中存储的数据来达到我们的效果。</p> <p>需求:</p> <ul><li>创建A/B两个页面，A用于提交数据然后跳转，B用于获取vuex中的数据信息</li> <li>在store文件夹下面创建modules文件夹以此来达到模块化，在store根目录下创建getters.js和index.js</li> <li>在modules文件夹下创建user.js来作为用户模块</li></ul> <p>目录结构:</p> <div class="language- extra-class"><pre class="language-text"><code>    store
        modules
            user.js
        getters.js
        index.js
    views
        home
            index.vue
        me
            index.vue
</code></pre></div><p>下面直接贴代码</p> <div class="language- extra-class"><pre class="language-text"><code>home.vue


&lt;template&gt;
  &lt;div&gt;
    &lt;div class=&quot;btn&quot; @click=&quot;setUser&quot;&gt;修改用户信息&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  methods: {
    setUser () {
      let users = {name: '张三', age: 30, sex: 'woman'}
      this.$store.dispatch('setUsers',users)
      this.$router.push({name: 'me'})
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
.btn {
  color: #fff;
  padding: 20px;
  background-color: red;
}
&lt;/style&gt;

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>me.vue


&lt;template&gt;
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li&gt;姓名: {{userinfo.name}}&lt;/li&gt;
      &lt;li&gt;性别: {{userinfo.sex}}&lt;/li&gt;
      &lt;li&gt;年龄: {{userinfo.age}}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import {mapGetters} from 'vuex'
export default {
  computed: {
    ...mapGetters(['userinfo'])
  }
}
&lt;/script&gt;

&lt;style&gt;

&lt;/style&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>user.js


const state = {
    userinfo: null
}

const mutations = {
    //获取用户信息
    SET_USERS (state,userinfo) {
        state.userinfo = userinfo
    }
}

const actions = {
    // 更新用户信息
    setUsers ({commit}, userinfo) {
        commit('SET_USERS',userinfo)
    }
}

export default {
    state,
    actions,
    mutations
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>getters.js



const getters = {
    userinfo: state =&gt; state.user.userinfo
}
export default getters
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>index.js


import Vue from 'vue'
import getters from './getters'
import user from './modules/user'
import Vuex from 'vuex'

Vue.use(Vuex)

const store = new Vuex.Store({
  modules: {
    user
  },
  getters
})

export default store


</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/Book/assets/js/app.e93a8c16.js" defer></script><script src="/Book/assets/js/2.ae30280c.js" defer></script><script src="/Book/assets/js/15.e7acb49b.js" defer></script>
  </body>
</html>
